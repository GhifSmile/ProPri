# -*- coding: utf-8 -*-
"""ProPri.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dg2rFKckbjaLlrRVqC5FggbKBxkwL7d0
"""

! pip install kaggle

"""Menginstall library kaggle."""

! mkdir ~/.kaggle

"""Membuat direktori dengan nama ".kaggle"."""

! cp kaggle.json ~/.kaggle/

"""Copy "kaggle.json" ke dalam direktori yang telah dibuat. """

! chmod 600 ~/.kaggle/kaggle.json

"""Mengalokasikan izin yang diperlukan untuk file tersebut."""

# Mendownload dan menyiapkan dataset 
! kaggle datasets download iabhishekofficial/mobile-price-classification

"""Mendownload dataset mobile price classification."""

# Mengekstrak zip file
import zipfile

local_zip = '/content/mobile-price-classification.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/content')
zip_ref.close()

"""Melakukan ekstraksi pada file dengan ekstensi zip agar dataset yang diperlukan dapat digunakan."""

# Mengubah dataset menjadi dataframe
import pandas as pd

df = pd.read_csv('/content/train.csv')
df.head()

"""Melihat dataset dengan menampilkan lima sampel awal dari dataset pada dataframe.

Deskripsi variabel:
1. battery_power = energi total yang dapat disimpan baterai dalam satu waktu diukur dalam mAh
2. blue = ada tidaknya bluetooth
3. clock_speed = kecepatan di mana mikroprosesor mengeksekusi instruksi
4. dual_sim = mendukung dual sim atau tidak
5. fc = front camera dalam mega pixels
6. four_g = mendukung 4G atau tidak
7. int_memory = kapasitas internal memori dalam Gigabytes
8. m_dep = kedalaman hp dalam cm
9. mobile_wt = berat hp 
10. n_cores = jumlah cores dari processor
11. pc = kamera utama dalam mega pixels
12. px_height = tinggi resolusi pixel
13. px_width = lebar resolusi pixel
14. ram = jumlah ram dalam Mega Bytes
15. sc_h = tinggi layar ponsel dalam cm
16. sc_w = lebar layar ponsel dalam cm
17. talk_time = waktu terlama satu kali pengisian baterai akan bertahan saat terakhir kali Anda berada
18. three_g = mendukung 3G atau tidak
19. touch_screen = mendukung layar sentuh atau tidak
20. wifi = mendukung wifi atau tidak
21. price_range = variabel target dengan nilai 0 (biaya rendah), 1 (biaya sedang), 2 (biaya tinggi) dan 3 (biaya sangat tinggi)
"""

# Melihat informasi mengenai dataset
df.info()

"""Melihat informasi yang ada pada dataset. Terlihat bahwasanya dataset memiliki 2000 sampel."""

# Melihat deskripsi statistik dataset
df.describe()

"""Melihat deskripsi statistik pada dataset. Dapat menjadi catatan, bahwasanya tidak akan rasional apabila nilai pada px_height, px_width, sc_h, sc_w sama dengan 0. Karena nilai-nilai yang ada pada variabel tersebut merepresentasikan dimensi layar hp."""

# Melihat apakah ada missing value pada dataset
df.isnull().sum()

"""Melihat apakah ada atau tidaknya missing value pada dataset. Terlihat bahwasanya tidak ada missing value pada dataset."""

# Memeriksa rasionalitas beberapa variabel
px_h = (df.px_height==0).sum()
px_w = (df.px_width==0).sum()
sc_h = (df.sc_h==0).sum()
sc_w = (df.sc_w==0).sum()

"""Memeriksa rasionalitas beberapa variabel, hal ini diperlukan untuk melihat ada atau tidaknya nilai pada variabel yang tidak rasional."""

print(px_h)
print(px_w)
print(sc_h)
print(sc_w)

# Menghapus nilai yang tidak rasional pada variabel
df = df.loc[(df[['px_height','sc_w']]!=0).all(axis=1)]
df.shape

"""Tersisa 1819 sampel setelah menghilangkan sampel yang mengandung variabel dengan nilai yang tidak rasional."""

# Menangani Outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada tiap variabel
import seaborn as sns

sns.boxplot(x=df['battery_power'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel battery_power."""

sns.boxplot(x=df['blue'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel blue."""

sns.boxplot(x=df['clock_speed'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel clock_speed."""

sns.boxplot(x=df['dual_sim'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel dual_sim."""

sns.boxplot(x=df['fc'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel fc."""

sns.boxplot(x=df['four_g'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel four_g."""

sns.boxplot(x=df['int_memory'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel int_memory."""

sns.boxplot(x=df['m_dep'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel m_dep."""

sns.boxplot(x=df['mobile_wt'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel mobile_wt."""

sns.boxplot(x=df['n_cores'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel n_cores."""

sns.boxplot(x=df['pc'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel pc."""

sns.boxplot(x=df['px_height'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel px_height."""

sns.boxplot(x=df['px_width'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel px_width."""

sns.boxplot(x=df['ram'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel ram."""

sns.boxplot(x=df['sc_h'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel sc_h."""

sns.boxplot(x=df['sc_w'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel sc_w."""

sns.boxplot(x=df['talk_time'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel talk_time."""

sns.boxplot(x=df['three_g'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel three_g."""

sns.boxplot(x=df['touch_screen'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel touch_screen."""

sns.boxplot(x=df['wifi'])

"""Melihat ada tidaknya outliers dengan IQR Method dan menggunakan boxplot untuk visualisasi pada variabel wifi."""

# Proses drop outliers
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR=Q3-Q1
df=df[~((df<(Q1-1.5*IQR))|(df>(Q3+1.5*IQR))).any(axis=1)]
 
# Cek ukuran dataset setelah outliers didrop
df.shape

"""Melakukan drop outliers. Terdapat 1368 sampel setelah melakukan drop pada sampel yang memiliki outliers."""

# Commented out IPython magic to ensure Python compatibility.
# Melakukan proses analisis data dengan teknik Univariate EDA
import matplotlib.pyplot as plt
# %matplotlib inline

df.hist(bins=50, figsize=(20,15))
plt.show()

l_three = (df.price_range==3).sum()
l_two = (df.price_range==2).sum()

print(l_three)
print(l_two)

"""Dari histogram di atas, terdapat informasi bahwasanya pada tiap label/target price_range jumlahnya tidak berbeda secara signifikan, dengan kata lain, hal tersebut bisa dikatakan proporsional. Jumlah tertinggi ada pada target 3 (biaya sangat tinggi)."""

# Menemukan variabel penting dengan scikit-learn menggunakan model random forest
from sklearn.model_selection import train_test_split

b = df['price_range'] 


li = list(df.columns.values[:20])
a = df[li]

# Split dataset menjadi train dan test
a_train, a_test, b_train, b_test = train_test_split(a, b, test_size=0.2, random_state=123)

"""Menemukan variabel penting dengan scikit-learn menggunakan model random forest yang telah dilatih oleh train test sementara."""

from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics

clf=RandomForestClassifier(n_estimators=100)

clf.fit(a_train,b_train)

y_pred=clf.predict(a_test)


print("Accuracy:",metrics.accuracy_score(b_test, y_pred))

"""Akurasi yang didapat kurang mumpuni, maka dari itu dilakukan pengambilan variabel penting untuk optimalisasi akurasi."""

var_imp = pd.Series(clf.feature_importances_,index=list(df.columns.values[:20])).sort_values(ascending=False)
var_imp

"""Melihat skor kepentingan variabel terhadap dataset."""

# Membuat bar plot
sns.barplot(x=var_imp, y=var_imp.index)
plt.xlabel('Skor variabel penting')
plt.ylabel('Variabel')
plt.title('Visualisasi variabel penting')
plt.legend()
plt.show()

"""Memvisualisasikan skor kepentingan variabel. Terlihat bahwasanya ram merupakan variabel yang sangat penting. Kemudian ambil beberapa variabel penting lainnya dengan tolak ukur relatif berdasarkan spesifikasi, maka diambil beberapa variabel penting, yaitu ram, battery_power, px_width, px_height, mobile_wt, dan int_memory."""

from sklearn.model_selection import train_test_split

y = df['price_range'] 

# Ambil fitur penting
X = df[['px_width', 'px_height', 'battery_power', 'ram', 'mobile_wt', 'int_memory']]
# Split dataset menjadi train dan test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)

"""Melakukan pembagian dataset terhadap variabel penting menjadi train test. Kemudian akan diterapkan pada tiga model yang mana pada akhirnya dilakukan evaluasi untuk memilih model yang optimal."""

print(X_test.shape)
print(X_train.shape)

"""Data train memiliki 1094 sampel, sedangkan data test memiliki 274 sampel dengan pembagian 80:20."""

# Model KNN
from sklearn.neighbors import KNeighborsClassifier
from sklearn import metrics

knn = KNeighborsClassifier(n_neighbors=9)

knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)

a_KNN = metrics.accuracy_score(y_test, y_pred)
print("Accuracy:",a_KNN)

"""Pada model KNN diambil jumlah tetangganya bernilai 9. karena tidak ada metode terkhusus dalam memilih jumlah nilai tetangga, maka dilakukan metode intuisi dengan mengambil jumlah nilai tetangga ganjil terhadap kelas yang genap."""

# Model AdaBoost dengan base estimator svc
from sklearn.ensemble import AdaBoostClassifier
from sklearn.svm import SVC
from sklearn import metrics

svc=SVC(probability=True, kernel='linear')
abc = AdaBoostClassifier(n_estimators=50,
                         base_estimator=svc,
                         learning_rate=1)

model = abc.fit(X_train, y_train)

y_pred = model.predict(X_test)

a_AdBoost = metrics.accuracy_score(y_test, y_pred)
print("Accuracy:",a_AdBoost)

"""Pada model AdaBoost digunakan base_estimator svc untuk optimalisasi yang mana sebelumnya secara default menggunakan Decision Tree."""

# Model random forest
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics

clf=RandomForestClassifier(n_estimators=100)

clf.fit(X_train,y_train)

y_pred=clf.predict(X_test)

a_RF = metrics.accuracy_score(y_test, y_pred)
print("Accuracy:",a_RF)

"""Pada model Random Forest dilakukan optimalisasi sebelumnya dengan mengambil variabel-variabel penting."""

kump_model = {'RF': a_RF, 'KNN': a_KNN, 'AdBoost_svc': a_AdBoost}
keys = kump_model.keys()
values = kump_model.values()

plt.bar(keys, values)
plt.title('Perbandingan akurasi model')
plt.ylabel('Score')

"""Dari visualisasi yang ada terdapat interpretasi bahwasanya tiap model tidak terlalu berbeda secara signifikan terhadap skor akurasi. Namun, dari ketiga model yang ada, model AdaBoostlah yang paling optimal dengan memberikan skor akurasi di atas 95%. Maka pada kasus klasifikasi rentang harga hp ini dapat disimpulkan bahwa penggunaan model AdaBoost sangat optimal."""